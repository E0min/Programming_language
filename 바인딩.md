
# 바인딩
---
> 바인딩이란 프로그램의 어떤 기본 단위가 가질 수 있는 구성 요소와 그 값 또는 성격을 을 연관짓는 것이다.

Ex)
```c
1. int i;  // 변수와 타입 사이의 연관 -> 컴파일 시점에 바인딩
2. i = 0;  // 변수와 값 사이의 연관 -> 실행 시점에 바인딩
3. 변수와 주소 사이의 연관 -> 메모리 적재 시점에 바인딩
4. int a, b; 
    a + b;  // 연산과 심볼과의 연관 -> 언어 설계 시점에 + 가 덧셈인 것을  바인딩
5.  ...
    printf("라이브러리 부프로그램 실행"); // 라이브러리 부프로그램 호출과 부프로그램 코드와의 연관 -> 링크 시점 바인딩
    ...
```

## 1. 변수의 속성 바인딩

### __정적 바인딩__
  * 바인딩이 실행 시간이 시작되기 전에 일어난다.
  * 프로그램 실행 전체에 걸쳐서 변하지 않는 상태로 남아 있는 경우.  
<br>

### __동적 바인딩__
  * 바인딩이 실행 시간 중에 일어난다.
  * 프로그램 실행 과정에서 변경될 수 있는 경우. 

> C와 Java 같은 경우 
> ```java
> int i // 정적 바인딩
> ```
> Python 같은 경우
> ```python
> i = 10
> i = "10"
> i = 10.5 # 변수 i와 바인딩 된 주소가 실행 시간중 변경 된다. 
> ```
<br>

## 2. 타입 바인딩
변수는 프로그램에서 참조되기 전에 어떤 데이터 타입에 바인딩 되어야한다. 이 바인딩의 두가지 중요한 점은 

1. 타입의 명세: 명시적 선언과 묵시적 선언
2. 언제 데이터 타입 바인딩이 일어나는가
<br>

### 정적 타입 다인딩
  * 변수에 바인딩된 타입은 프로그램 단위(전체코드, 함수, 블럭 등등)의 존속기간 동안 고정된다. --> __정적 바인딩__ 이 일어난다.
  * 명시적 선언: 타입을 명세하여 결정 
    > 명시적 선언의 예시
    > ```c
    > int i // int로 명세하여 정수형 타입 바인딩
    > ```
  * 묵시적 선언: 타입에 아닌 디폴트 규칙(언어 생성 시점에 바인딩)을 통해 타입 결정
<br>

### 동적 타입 바인딩

  * 동적 타입 바인딩에서는 변수의 타입이 선언문으로 명세되지 않으며, 묵시적으로도 정해지지 않는다.
  * 대신에, 배정문에서 변수에 어떤 값이 할당될 때 그 배정문의 우측에 있는 값의 타입으로 바인딩된다. 
  * 또한 __동적 바인딩__ 이 일어나는 변수의 타입은 프로그램의 실행동안 바뀔 수 있으며, 다른 타입의 값은 다른 크기의 기억공간을 요구 할 수 있기 때문에 배정문은 그 변수를 다른 주소나 메모리 셀에 바인딩 할 수도 있다.
    > ```python
    > a = 10
    > a = "10"
    > a = 10.5
    > #전부 다 다른 타입으로 새로운 값이 들어올때 마다 그 값의 타입으로 바인딩된다.
    > ```

  * 동적 타입 바인딩의 __장점과 단점__


<br>

## 3. 기억공간 바인딩과 존속기간(life time)
명령형 프로그래밍 언어의 근본적인 특정은 __그 변수들에 대한 기억공간 바인딩의 설계__ 에 의해 많은 부분이 결정된다. 변수에 바인딩되는 메모리는 __할당과 회수__ 의 과정을 거친다. 변수에 바인딩되는 메모리 셀은 가용 메모리 풀로부터 가져오는데 이 과정을 기억장소 __할당__ 이라고 한다. 그리고 그 메모리 셀을 다시 가용 메모리 풀로 반환하는 것이 __회수__ 이다. __변수의 존속기간__ 은 변수가 특정 메모리 위치에 바인딩 되어 있는 기간이며 할당부터 회수까지의 시간이라고 할 수 있다.

### 존속 기간에 따른 변수들의 4가지 분류 
#### 1. 정적변수
* 정적변수는 프로그램이 실행되기 전에  메모리 셀에 바인딩 되어 프로그램 종료 시 까지 동일한 메모리 셀에 바인딩 된다.
* 예시:
  * 전역 변수, 
  * 지역적 정적 변수(함수에 선언된 static variable)
* 장점:
  * 효율적, 정적변수의 주소지정은 직접적이어서 빠르다.
  * 실행시간에 할당과 회수를 하는 부담이 없음.
* 단점:
  * 프로그램 유연성 감소
  * 기억공간이 변수들 간에 공유 될 수 없음


#### 2. 스택 - 동적 변수
* 변수의 선언문이 실제 선언 될 때, 기억공간에 바인딩 그러나 변수의 타입은 정적으로 바인딩 된다.
    > 변수의 주소 바인딩은 런타임, 타입 바인딩은 컴파일 타임에 바인딩.
    > 변수의 속성에 따라 바인딩 시점이 다르다.
* 예시:
  * C의 함수, Java의 메소드의 시작부분에 변수가 선언된 경우: 호출 시 바인딩, 종료 시 회수
  * C의 함수, Java의 메소드의 중간부분에 변수가 선언된 경우: 호출 시 바인딩, 종료 시 회수 그러나 변수의 사용은 선언 이후 부터(aka. 변수 선언 부분이 실행될 때까지 가시화 되지 않는다.)
* 장점:
  * 유연성 증가: 재귀적 부프로그램 사용가능
* 단점:
  * 할당과 회수에 대한 부담
  * 간접 주소지정이 될 경우 접근이 느려진다.
  * 부프로그램이 과거민감하지 않음

#### 3. 명시적 힙 - 동적변수
* 프로그래머가 명세하는 명시적 실행 - 시간 __명령어__ 에 의해 할당되고 회수되는 이름이 없는(추상)메모리 셀을 의미한다. 이 변수들은 힙으로부터 할당되고 회수된다. 이름이 없기 때문에 포인터나 참조변수를 통해 참조가 가능하다.
* 예시:
  * C언어의 malloc()함수와 free
  * Java의 new 연산자와 가비지 콜렉션
* 장점:
  * 연결리스트나 트리와 같은 동적 구조체 구현 가능
* 단점:
  * 포인터나 참조 변수의 올바른 사용이 어렵다
  * 메모리에 대한 이해가 필요하다.
  
#### 4. 묵시적 힙 - 동적변수
* 묵시적 힙 - 동적 변수는 값이 배정될 때 힙 기억 장소에 바인딩 되는 것이다. ( 명시적 힙 - 동적 변수와는 달리 명령어가 없다.)
* 예시:
  * Python에서의 배정문 high = [1,2,3,4,5,6]
* 장점: 
  * 최고의 유연성
* 단점:
  * 모든 동적 속성들을 유지하는데 필요한 실행시간의 부담






